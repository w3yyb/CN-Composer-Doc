<!--
    tagline: 如何降低自动加载的性能影响
-->

# 优化自动加载

默认情况下, Composer自动加载器运行相对较快。但是, 由于 PSR-4 和 PSR-0 自动加载规则的设置方式, 它需要在最终解析 类名 之前检查文件系统。这会使事情变慢一些, 但在开发环境中很方便, 因为当您添加新类时, 它可以立即被发现/使用, 而不必重新生成自动加载器配置。

但是, 问题是在生产中, 您通常希望事情尽可能快地发生, 因为您可以在每次部署时重新生成配置, 并且在部署之间不随机出现新类.

因此, Composer提供了一些优化自动加载器的策略。

> **注意:** 在**开发环境中**你**不应该**启用任何这些优化, 因为在添加/移除类时它们都将导致各种问题。性能增益在开发设置中不值得费心.

## 优化级别 1: 类映射生成

### 如何运行它?

有几个选项可以启用此优化:

- 在composer.json的配置键中设置 `"optimize-autoloader": true` 
- 用 `-o` / `--optimize-autoloader` 调用 `install` 或 `update` 
- 用 `-o` / `--optimize`调用 `dump-autoload` 

### 它做什么?

类映射生成实质上将 PSR-4/PSR-0 规则转换为 classmap 规则。这使一切都相当快, 因为对于已知的类, 类映射立即返回路径, Composer可以保证类在那里, 所以不需要文件系统检查。

在 PHP 5.6 + 上, 类映射也缓存在 opcache 中, 从而大大提高了初始化时间。如果确保 opcache 已启用, 则类映射应立即加载, 然后类加载速度就很快.

### 权衡

这种方法没有真正的权衡。它应该始终在生产中启用.

唯一的问题是它不跟踪自动加载遗失 (即当它找不到给定的类时), 因此那将回退到 PSR-4 规则, 仍然可能导致缓慢的文件系统检查。要解决此问题, 存在两个2级优化选项, 如果您对项目中不存在的类进行了大量的 class_exists 检查, 则可以决定启用二者之一。

## 优化级别 2/A: 权威类映射

### 如何运行它?

有几个选项可以启用此优化:

- 在composer.json的配置键中设置  `"classmap-authoritative": true` 
- 用 `-a` / `--classmap-authoritative` 调用 `install` 或 `update` 
- 用 `-a` / `--classmap-authoritative` 调用 `dump-autoload` 

### 它做什么?

启用此功能可自动启用级别1类映射优化.

这个选项非常简单, 它是说如果在 classmap 中找不到什么东西, 那么它就不存在, 自动加载器不应该根据 PSR-4 规则来尝试查看文件系统.

### 权衡

此选项使自动加载器始终返回非常快。另一方面, 它也意味着, 如果某个类是在运行时由于某种原因而生成的, 它将不允许被自动加载。如果您的项目或任何依赖项这样做, 那么您可能会在生产中遇到 "class not found" 问题。小心地启用此选项.

> 注意: 这不能与级别为 2/B 的优化相结合。你必须选择一个, 因为他们以不同的方式解决同一个问题.

## 优化级别 2/B: APCu 缓存

### 如何运行它?

有几个选项可以启用此优化:

- 在composer.json的配置键中设置 `"apcu-autoloader": true` 
- 用 `--apcu-autoloader` 调用 `install` 或 `update` 
- 用 `--apcu` 调用 `dump-autoload`

### 它做什么?

 此选项增加了APCu缓存作为类映射的回退。不过, 它不会自动生成类映射, 因此, 如果您愿意, 仍应手动启用级别1优化.

无论是否找到类, 这一事实总是缓存在 APCu 中, 以便在下次请求时可以快速返回.

### 权衡

此选项需要 APCu扩展, 您可能可用或不可用。它还使用APCu内存用于自动加载, 但使用它是安全的,不会出现像上面的权威类映射优化一样导致类没有找到。

> 注意: 这不能与级别 2/优化进行组合。你必须选择一个, 因为他们以不同的方式解决同一个问题.


## 注意:

> 注意: 当你添加或删除了类以后,要重新执行以上命令
